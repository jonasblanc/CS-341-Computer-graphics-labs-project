# Project: Infinite map generation

## Abstract
The goal of this project is to generate an infinte map. The implementation relies on the marching cubes algorithm and makes use of multiple three dimensional Perlin Noise functions to make it aesthetically pleasing and make it seem randomly generated. All design choices are made to prioritize the use of the GPU and keep the project computationnally efficient in order to run smoothly on most modern day machines.

## Technical Approach

### Marching cube alorithm

We implemented a JS version of the marching cube alorithm. We followed [Ben Anderson's paper](https://www.cs.carleton.edu/cs_comps/0405/shape/marching_cubes.html) for the main steps. First we created a version where the vertices are placed on the middle of the edges, then we modified it to interpolate their exact position based one the noise value at the cube corners. We had to adapat our code to integrate the lookup table (used as an efficient way to retrieve cube faces based on the corner noise function) publied in [Paul Bourke's paper](http://paulbourke.net/geometry/polygonise/). We used our own design to iterate over cubes and to translate the coordinates for the noise function or to draw the mesh, resulting in quite a fiew index translation.

### Partial chunk generation

In order to give the impression of infinite terrain, we rely on partial chunk generation. This straightforward yet effective method makes the computational load bearable. Indeed, we partition the rendered area of the map in 9 chunks of given dimensions (10x10x10 for example) to generate our map. Whenever the camera is moving, we delete in memory the 3 chunks that are in the opposite direction of the camera movement and compute the 3 new chunks. Like that, we always have 9 chunks, we don't have too many computation to do and we can move to infinity in each directions.

![Original plane chunks](proposal_template/images/plane1.png)

![Plane chunks generated by moving up](proposal_template/images/plane2.png)

- An easy interaction with the scene where we can move the camera in the x and y direction, allows us to see the generation of the terrain and see that it is indeed infinite.

### Mist
The partial chunk generation has it's shortcomings. The main one being the fact that you can clearly see the linear disparity between the end of the generated area and the background. We implemented a mist feature to work around that problem. For all generated points that are further than a certain threshold, we mix their color with the color of the sky. The quantity of the sky color in that mixture is linearly dependent on the distance to the aforementionned threshold.

###Terrain specialisation
One of our extension was to add different terrains with different features. We chose to have 3 differents terrains: mountains, archipelagos and floating islands. To generate coherent terrains and not just random looking shapes, we decided to do a mix between a 2D perlin-noise function to compute a height and a 3D perlin-noise to modify it and create hollow surfaces. Only using the 3D perlin-noise would have allowed to create complicated terrains, but this approach seemed to give more realistic ones.

Our implementation works as follows: we first call a 2D noise function and use the value returned to choose between our 3 terrains using predefined thresholds. This way, there would be some continuity in the kind of terrains generated, but it will still be random and allow different terrains type to be mixed together. Then, we call our terrain method which returns the value for the 3D coordinate used in the marching cube.

Our 3 terrains work as following:

####Mountains
Mountains are charachterised by higher average altitude and sharper peaks. We decided not to let mountains having holes, therefore, this terrain doesn't use our 3D perlin-noise and could be implemented without the marching-cube algorithm. In order to have a higher altitude, we added a base height to our 2D noise function for the height. In order to add sharper peaks, we used many octaves and a quite height amplitude multiplier factor in our 2D perlin FBM. Finally, in order to have smooth surfaces with the marching cube algorithm, and to be able to compute the normals as the gradient of a signed distance function, we return the difference between the z axis and this height.

####Archipelagos
Archipelagos are charachterised by more continuous height differences without any peaks and can have holes to create sort of bridges. To avoid having peaks, we used only 1 octave in our 2D perlin FBM for the height. Then to create holes and use the full power of the marching-cube algorithm, if z is smaller than the height (i.e. we would be "inside the terrain"), we use our 3D perlin FBM function with tweeked paramters. This will potentially create holes by returnng values interpreted as "outside the terrain" even if we are under the height computed with the 2D FBM.

####Floating Islands
Floating islands are flying on top of water. Basically, we used a max and min threshold where we are for sure outside the surface. Otherwise, we use our 3D perlin FBM with parameters that most of the time return a value interpreted as outside the surface and just sometimes as inside the surface, which will create blocks of earth on top of the water.

